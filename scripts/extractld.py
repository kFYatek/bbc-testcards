#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import json
import math
import os
import subprocess
import sys

import numpy
import scipy.fft
import scipy.signal

import common


def mean_with_outliers(data, max_delta=0.25):
    result = numpy.mean(data, axis=0)
    if data.shape[0] > 1:
        deltas = numpy.abs(data - result)
        valid_values = (deltas <= ((max_delta * (data.shape[0] - 1)) / data.shape[0]))
        result = numpy.sum(data * valid_values, axis=0) / numpy.sum(valid_values, axis=0)
        result[~numpy.isfinite(result)] = 0.0
    return result


def deghost(data, shift, weight):
    return (data - common.apply_shift(data, shift) * weight) / (1.0 - weight)


def half_freqs(data):
    data = numpy.swapaxes(data, 0, len(data.shape) - 1)
    fft = scipy.fft.rfft(data, axis=0)
    fft[fft.shape[0] // 2:] = 0.0
    data = scipy.fft.irfft(fft, n=data.shape[0], axis=0)
    return numpy.swapaxes(data, 0, len(data.shape) - 1)


def deqam(data):
    cosine = numpy.array(([1.0, 0.0, -1.0, 0.0] * math.ceil(data.shape[-1] / 4))[:data.shape[-1]])
    sine = numpy.array(([0.0, 1.0, 0.0, -1.0] * math.ceil(data.shape[-1] / 4))[:data.shape[-1]])
    chroma_u = half_freqs(sine * data)
    chroma_v = half_freqs(cosine * data)
    return chroma_u + 1.0j * chroma_v


def depal(chroma):
    palmask = numpy.ones(chroma.shape, dtype=numpy.bool)
    palmask[1::2] = ~palmask[1::2]
    palmask[:, 1::2] = ~palmask[:, 1::2]
    chroma[palmask] = -numpy.imag(chroma[palmask]) - 1.0j * numpy.real(chroma[palmask])
    return chroma


def deinterlace(data):
    output = numpy.ndarray(data.shape, dtype=data.dtype)
    output[0::2] = data[:data.shape[0] // 2]
    output[1::2] = data[data.shape[0] // 2:]
    return output


def _main(*args):
    parser = argparse.ArgumentParser(
        description='Decode a still image from multiple frames of TBC information decoded using ld-decode. For now, only supports PAL CAV Laserdisc sources and includes manual tweaks tuned for the Test Card F sample found on the 1986 BBC Domesday Community South disc.')
    parser.add_argument('input_file', type=str,
                        help='TBC file to read data from. A matching *.json file is required too.')
    parser.add_argument('output_file', type=str,
                        help='Output file name. Will be passed through to ImageMagick.')
    parser.add_argument('start_frame', type=int, nargs='?', default=3000,
                        help='CAV frame number of the first frame the image to decode appears on. Default: 3000.')
    parser.add_argument('frame_count', type=int, nargs='?', default=23,
                        help='Number of frames the still image appears on. Must be at least 4. Default: 23.')
    args = parser.parse_args(args)

    if args.frame_count < 4:
        raise Exception('This script requires at least 4 frames to operate')

    with open(args.input_file + '.json') as f:
        metadata = json.load(f)

    assert metadata['videoParameters']['system'] == 'PAL'
    assert metadata['videoParameters']['fieldWidth'] == 1135
    assert metadata['videoParameters']['fieldHeight'] == 313

    input_file_first_field = 0

    fields = iter(metadata['fields'])
    field = next(fields)
    if not field['isFirstField']:
        input_file_first_field -= 1
        field = next(fields)
    assert field['isFirstField']
    for vbi in field['vbi']['vbiData']:
        if vbi & 0xf00000 == 0xf00000:
            frame_bcd = vbi ^ 0xf00000
            frame = 0
            multiplier = 1
            while frame_bcd > 0:
                frame += (frame_bcd % 16) * multiplier
                frame_bcd //= 16
                multiplier *= 10
            input_file_first_field += 2 * frame
            break
    else:
        raise Exception('Invalid input file')

    with open(args.input_file, 'rb') as f:
        f.seek(metadata['videoParameters']['fieldWidth'] * metadata['videoParameters'][
            'fieldHeight'] * 2 * (2 * args.start_frame - input_file_first_field))
        data = f.read(metadata['videoParameters']['fieldWidth'] * metadata['videoParameters'][
            'fieldHeight'] * 4 * args.frame_count)

    data = numpy.ndarray((len(data) // (
            metadata['videoParameters']['fieldWidth'] * metadata['videoParameters'][
        'fieldHeight'] * 4), metadata['videoParameters']['fieldHeight'] * 2,
                          metadata['videoParameters']['fieldWidth']), dtype=numpy.uint16,
                         buffer=data)

    # Range that comes from metadata generated by ld-decode:
    # input = (data - 16199.0) / 37817.0
    # Range measured empirically for best match:
    inp = (data - 16221.0) / 37053.0
    # Again, empirically derived values
    inp = deghost(inp, -4.5, 0.133333)

    data = numpy.ndarray((4, inp.shape[1], inp.shape[2]))
    for i in range(4):
        data[i, :] = mean_with_outliers(inp[i::4])

    luma = numpy.mean(data, axis=0)

    chroma = deqam(data - luma)
    burst = numpy.mean(chroma[:, :, 109:129], axis=-1)
    chroma = chroma.transpose((2, 0, 1))
    chroma = chroma * numpy.exp(1.0j * (0.75 * numpy.pi - numpy.angle(burst)))
    chroma = chroma.transpose((1, 2, 0))
    chroma = depal(chroma)
    chroma = numpy.mean(chroma, axis=0)

    luma = deinterlace(luma)
    chroma = deinterlace(chroma)
    chroma *= (3.0 / (14.0 * numpy.abs(numpy.mean(chroma[44:617, 109:129]))))

    fullcolor = numpy.ndarray((luma.shape[0], luma.shape[1], 3))
    fullcolor[:, :, 0] = luma
    # 5/6 and 7/8 fixups determined empirically
    fullcolor[:, :, 1] = 5.0 * numpy.real(chroma) / 6.0
    fullcolor[:, :, 2] = 7.0 * numpy.imag(chroma) / 8.0

    fullcolor = numpy.matvec(numpy.array(
        [[1.0, 0.0, 1.1402508551881414], [1.0, -0.3939307027516405, -0.5808092090310976],
         [1.0, 2.028397565922921, 0.0]]), fullcolor)

    output = fullcolor[44:620, 174:1107]
    output = scipy.signal.resample(output, 777, axis=1)
    output = numpy.pad(output, ((0, 0), (11, 0), (0, 0)), mode='edge')
    output = common.apply_shift(output, 1.0 / 3.0, axis=1)
    outbuf = bytearray(numpy.prod(output.shape) * 2)
    outarr = numpy.ndarray(output.shape, dtype=numpy.uint16, buffer=outbuf)
    outarr[:] = numpy.round(
        numpy.minimum(numpy.maximum(output * (219.0 * 256.0) + 4096.0, 0.0), 65535.0))

    subprocess.run(
        ['magick', '-size', f'{output.shape[1]}x{numpy.prod(output.shape[0])}', '-depth', '16',
         'rgb:-', '+profile', 'icc', '-profile',
         os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
                      'ITU-601-625-video16-v4.icc'), args.output_file], input=outbuf, check=True)


if __name__ == '__main__':
    sys.exit(_main(*sys.argv[1:]))
